//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ErrorResponseStatus.
const (
	False ErrorResponseStatus = false
)

// Defines values for FileType.
const (
	Dir  FileType = "dir"
	File FileType = "file"
)

// Defines values for Operation.
const (
	OperationArchive    Operation = "archive"
	OperationDelete     Operation = "delete"
	OperationDownload   Operation = "download"
	OperationIndex      Operation = "index"
	OperationMove       Operation = "move"
	OperationNewfile    Operation = "newfile"
	OperationNewfolder  Operation = "newfolder"
	OperationPreview    Operation = "preview"
	OperationRename     Operation = "rename"
	OperationSave       Operation = "save"
	OperationSearch     Operation = "search"
	OperationSubfolders Operation = "subfolders"
	OperationUnarchive  Operation = "unarchive"
	OperationUpload     Operation = "upload"
)

// Defines values for GetParamsQ.
const (
	GetParamsQArchive    GetParamsQ = "archive"
	GetParamsQDelete     GetParamsQ = "delete"
	GetParamsQDownload   GetParamsQ = "download"
	GetParamsQIndex      GetParamsQ = "index"
	GetParamsQMove       GetParamsQ = "move"
	GetParamsQNewfile    GetParamsQ = "newfile"
	GetParamsQNewfolder  GetParamsQ = "newfolder"
	GetParamsQPreview    GetParamsQ = "preview"
	GetParamsQRename     GetParamsQ = "rename"
	GetParamsQSave       GetParamsQ = "save"
	GetParamsQSearch     GetParamsQ = "search"
	GetParamsQSubfolders GetParamsQ = "subfolders"
	GetParamsQUnarchive  GetParamsQ = "unarchive"
	GetParamsQUpload     GetParamsQ = "upload"
)

// Defines values for PostParamsQ.
const (
	Archive    PostParamsQ = "archive"
	Delete     PostParamsQ = "delete"
	Download   PostParamsQ = "download"
	Index      PostParamsQ = "index"
	Move       PostParamsQ = "move"
	Newfile    PostParamsQ = "newfile"
	Newfolder  PostParamsQ = "newfolder"
	Preview    PostParamsQ = "preview"
	Rename     PostParamsQ = "rename"
	Save       PostParamsQ = "save"
	Search     PostParamsQ = "search"
	Subfolders PostParamsQ = "subfolders"
	Unarchive  PostParamsQ = "unarchive"
	Upload     PostParamsQ = "upload"
)

// Adapter Storage adapter key
type Adapter = string

// AdapterList List of all available storage adapter keys configured in the system
type AdapterList = []Adapter

// ArchiveName Archive name without extension (pathinfo PATHINFO_FILENAME extracts this, .zip added automatically)
type ArchiveName = string

// ArchiveRequest defines model for ArchiveRequest.
type ArchiveRequest struct {
	// Items Array of items for batch operations
	Items FileItemList `json:"items"`

	// Name Archive name without extension (pathinfo PATHINFO_FILENAME extracts this, .zip added automatically)
	Name ArchiveName `json:"name"`
}

// Basename Base name of the file or directory (extracted via basename() function)
type Basename = string

// CreateRequest Request to create a new file or folder (name validated against \\/?%*:|"<> characters)
type CreateRequest struct {
	// Name Name that must not contain \/?%*:|"<> characters
	Name Name `json:"name"`
}

// DeleteRequest defines model for DeleteRequest.
type DeleteRequest struct {
	// Items Array of items for batch operations
	Items FileItemList `json:"items"`
}

// DirectoryListingResponse Standard response containing directory contents and metadata.
//
// The 'adapter' field indicates which adapter was used for this response. When clients
// make their first request without specifying an adapter parameter (or with adapter=null),
// this field will contain the first configured adapter, allowing clients to discover and
// use it for subsequent requests. The 'storages' array contains all available adapters.
type DirectoryListingResponse struct {
	// Adapter Storage adapter key
	Adapter Adapter `json:"adapter"`

	// Dirname Directory path with adapter prefix
	Dirname DirectoryPath `json:"dirname"`

	// Files Array of files and directories (directories listed first, then files)
	Files FileList `json:"files"`

	// Storages List of all available storage adapter keys configured in the system
	Storages AdapterList `json:"storages"`
}

// DirectoryPath Directory path with adapter prefix
type DirectoryPath = string

// ErrorResponse Standard error response returned with 400 status code
type ErrorResponse struct {
	// Message Human-readable error message describing what went wrong
	Message string `json:"message"`

	// Status Always false for error responses
	Status ErrorResponseStatus `json:"status"`
}

// ErrorResponseStatus Always false for error responses
type ErrorResponseStatus bool

// Extension File extension without the dot (extracted via pathinfo)
type Extension = string

// FileContent Text content of a file
type FileContent = string

// FileItem Reference to a file or directory for batch operations (move, delete, archive)
type FileItem struct {
	// Path Full path with adapter prefix
	Path Path `json:"path"`

	// Type Type of the node - 'file' for files, 'dir' for directories
	Type FileType `json:"type"`
}

// FileItemList Array of items for batch operations
type FileItemList = []FileItem

// FileList Array of files and directories (directories listed first, then files)
type FileList = []FileNode

// FileNode Represents a file or directory in the file system
type FileNode struct {
	// Basename Base name of the file or directory (extracted via basename() function)
	Basename Basename `json:"basename"`

	// Dir Directory path with adapter prefix
	Dir *DirectoryPath `json:"dir,omitempty"`

	// Extension File extension without the dot (extracted via pathinfo)
	Extension *Extension `json:"extension,omitempty"`

	// LastModified Unix timestamp
	LastModified *Timestamp `json:"last_modified,omitempty"`

	// MimeType MIME type of the file (detected by filesystem)
	MimeType *MimeType `json:"mime_type,omitempty"`

	// Path Full path with adapter prefix
	Path Path `json:"path"`

	// Size File size in bytes (provided by filesystem StorageAttributes)
	Size *FileSize `json:"size,omitempty"`

	// Storage Storage adapter key
	Storage Adapter `json:"storage"`

	// Type Type of the node - 'file' for files, 'dir' for directories
	Type FileType `json:"type"`

	// Url Public URL to access the file
	Url *Url `json:"url,omitempty"`
}

// FileSize File size in bytes (provided by filesystem StorageAttributes)
type FileSize = int64

// FileType Type of the node - 'file' for files, 'dir' for directories
type FileType string

// Folder Subfolder information for tree navigation
type Folder struct {
	// Adapter Storage adapter key
	Adapter Adapter `json:"adapter"`

	// Basename Base name of the file or directory (extracted via basename() function)
	Basename Basename `json:"basename"`

	// Path Full path with adapter prefix
	Path Path `json:"path"`
}

// FolderList Array of folders
type FolderList = []Folder

// MimeType MIME type of the file (detected by filesystem)
type MimeType = string

// MoveRequest defines model for MoveRequest.
type MoveRequest struct {
	// Item Directory path with adapter prefix
	Item DirectoryPath `json:"item"`

	// Items Array of items for batch operations
	Items FileItemList `json:"items"`
}

// Name Name that must not contain \/?%*:|"<> characters
type Name = string

// Path Full path with adapter prefix
type Path = string

// RenameRequest defines model for RenameRequest.
type RenameRequest struct {
	// Item Full path with adapter prefix
	Item Path `json:"item"`

	// Name Name that must not contain \/?%*:|"<> characters
	Name Name `json:"name"`
}

// SaveRequest defines model for SaveRequest.
type SaveRequest struct {
	// Content Text content of a file
	Content FileContent `json:"content"`
}

// SearchFilter Search filter/pattern (case-insensitive, uses fnmatch with wildcards)
type SearchFilter = string

// SubfoldersResponse defines model for SubfoldersResponse.
type SubfoldersResponse struct {
	// Folders Array of folders
	Folders FolderList `json:"folders"`
}

// Timestamp Unix timestamp
type Timestamp = int64

// UnarchiveRequest defines model for UnarchiveRequest.
type UnarchiveRequest struct {
	// Item Full path with adapter prefix
	Item Path `json:"item"`
}

// UploadSuccessResponse defines model for UploadSuccessResponse.
type UploadSuccessResponse = []string

// Url Public URL to access the file
type Url = string

// Operation defines model for operation.
type Operation string

// Error Standard error response returned with 400 status code
type Error = ErrorResponse

// GetParams defines parameters for Get.
type GetParams struct {
	// Q Operation to perform. This parameter routes the request to the appropriate handler method.
	//
	// Valid operations and their HTTP methods:
	// - GET: index, subfolders, download, preview, search
	// - POST: newfolder, newfile, rename, move, delete, upload, archive, unarchive, save
	Q GetParamsQ `form:"q" json:"q"`

	// Adapter Storage adapter key to use. Optional parameter that allows clients to specify which storage adapter to use.
	//
	// Behavior:
	// - If omitted or null: Server returns the first configured adapter in the response, allowing clients to discover available adapters
	// - If provided but invalid: Server returns the first configured adapter (fallback behavior)
	// - If provided and valid: Server uses the specified adapter
	//
	// This allows clients to start with adapter=null, receive the adapter list in the response,
	// and then use a specific adapter in subsequent requests.
	Adapter *Adapter `form:"adapter,omitempty" json:"adapter,omitempty"`

	// Path Directory or file path with adapter prefix. Required for some operations.
	// - For index/subfolders/search: Directory path (defaults to 'adapter://')
	// - For preview/download: Full file path (required)
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// Filter Search filter (required when q=search). Case-insensitive, uses fnmatch with wildcards.
	Filter *SearchFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetParamsQ defines parameters for Get.
type GetParamsQ string

// PostJSONBody defines parameters for Post.
type PostJSONBody struct {
	union json.RawMessage
}

// PostMultipartBody defines parameters for Post.
type PostMultipartBody struct {
	// File File data to upload
	File openapi_types.File `json:"file"`

	// Name Target filename
	Name string `json:"name"`
}

// PostParams defines parameters for Post.
type PostParams struct {
	// Q Operation to perform. This parameter routes the request to the appropriate handler method.
	//
	// Valid operations and their HTTP methods:
	// - GET: index, subfolders, download, preview, search
	// - POST: newfolder, newfile, rename, move, delete, upload, archive, unarchive, save
	Q PostParamsQ `form:"q" json:"q"`

	// Adapter Storage adapter key to use. Optional parameter that allows clients to specify which storage adapter to use.
	//
	// Behavior:
	// - If omitted or null: Server returns the first configured adapter in the response, allowing clients to discover available adapters
	// - If provided but invalid: Server returns the first configured adapter (fallback behavior)
	// - If provided and valid: Server uses the specified adapter
	//
	// This allows clients to start with adapter=null, receive the adapter list in the response,
	// and then use a specific adapter in subsequent requests.
	Adapter *Adapter `form:"adapter,omitempty" json:"adapter,omitempty"`

	// Path Directory or file path with adapter prefix.
	// - For newfolder/newfile/upload/move/delete/archive/unarchive: Directory path where operation occurs
	// - For save/rename: Full path to the file
	Path string `form:"path" json:"path"`
}

// PostParamsQ defines parameters for Post.
type PostParamsQ string

// PostJSONRequestBody defines body for Post for application/json ContentType.
type PostJSONRequestBody PostJSONBody

// PostMultipartRequestBody defines body for Post for multipart/form-data ContentType.
type PostMultipartRequestBody PostMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute read operations
	// (GET /)
	Get(w http.ResponseWriter, r *http.Request, params GetParams)
	// CORS preflight
	// (OPTIONS /)
	Options(w http.ResponseWriter, r *http.Request)
	// Execute write operations
	// (POST /)
	Post(w http.ResponseWriter, r *http.Request, params PostParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Get operation middleware
func (siw *ServerInterfaceWrapper) Get(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetParams

	// ------------- Required query parameter "q" -------------

	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "adapter" -------------

	err = runtime.BindQueryParameter("form", true, false, "adapter", r.URL.Query(), &params.Adapter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "adapter", Err: err})
		return
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "filter", r.URL.Query(), &params.Filter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "filter", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Get(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Options operation middleware
func (siw *ServerInterfaceWrapper) Options(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Options(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Post operation middleware
func (siw *ServerInterfaceWrapper) Post(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostParams

	// ------------- Required query parameter "q" -------------

	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "adapter" -------------

	err = runtime.BindQueryParameter("form", true, false, "adapter", r.URL.Query(), &params.Adapter)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "adapter", Err: err})
		return
	}

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Post(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/{$}", wrapper.Get)
	m.HandleFunc("OPTIONS "+options.BaseURL+"/{$}", wrapper.Options)
	m.HandleFunc("POST "+options.BaseURL+"/{$}", wrapper.Post)

	return m
}
